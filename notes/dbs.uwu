lecture 1:

	fiit-databases.github.io
	lots of yapping
lecture 2:
	nothing useful
	stff with dbs like orde by , between , operangs...

	join : SELECT stlpec FROM tab1 INNER JOIN tab2 ON ...

lecture 3:
	sql syntax shit like create table , attributes / limiters like not null, unique , primary key ...
	showing off updates
	windowing -defining groups like by year
						-dows have option of sliding window

	important stuff is on slide 14,15 apperently mainly rank, denserank,rownumber
	mentioned array_agg() over(),lag(),lead()
	functions and procedures
	triggers

lecture 4:
	Data modeling
	he keepsyapping to us like a fren about this and that but it's all theoretical
	modeling layers:
		conceptual -> abstract / highlevel view for managers
		logical model-> detailed structure of talbes ...
		implementation -> postgres / working version
	entity relationship model:
		entities:
			entity:object irl
			attributes:property describing it
			entity set:similar entities
		relationships:
			relationship;association among two + entities
			-||- set set of relationships of the same type
			-||- degree number of entitiy sets participating( unary, binary , ternary)
		cardinality
		database relationships one to many , one to one , many to many , many to one
lecure 5:
	he keepsyapping to us like a fren about this and that 
	kardinalita - relationship between entities that has some weight (just some lines between ...)
	keys n stuff primary , foreign , super 
	normal forms:
		1st normal form - each entity has a primary key nad each column has an attribute
		2nd normal form - eliminate partitial dependencies: every non-key attribute depends on the entire composite key
		3rd normal form - each non-key attribute depends only on the whole primary key and nothing else
	kept yapping bout some abstract stuff

lecture 7:
	types ; in memory /disc oriented  
	-- paging and benchmarks/speeds overeall like rn he's talking about rule-based optimizer



exam prep:
  ROW_NUMBER()
  RANK()
  DENSE_RANK()
  PERCENT_RANK()
  LAG()
  LEAD()
  NTILE(n)
  CUME_DIST
Normal Forms - Description for Humans
	1NF (First Normal Form): One clear value per cell, no lists in one cell
	Arthur Dent’s multiple towels should each have their own entry
	2NF (Second Normal Form): Attributes fully depend on the whole composite key
	Marvin’s depressed thoughts depend fully on Marvin, not partially
	3NF (Third Normal Form): Each attribute only describes the primary key, nothing else
	Ford Prefect’s guide entries depend directly on the guide, not indirectly via Zaphod
	BCNF (Boyce-Codd Normal Form): Every detail about the Heart of Gold depends on its unique ID
	Infinite Improbability Drive depends directly on Heart of Gold, not on unrelated attributes
	4NF (Fourth Normal Form): Independent details like favorite drink and planet of origin stored separately
	Zaphod’s favorite drinks and visited planets in separate tables
	5NF (Fifth Normal Form): Cannot split tables without losing important galaxy connections
	Complex relationships between planets, galaxies, and Vogon poetry collections


Superkeys
	Any set of attributes that uniquely identifies a row.
	Includes unnecessary/redundant attributes.
	Every PK is a superkey, but not every superkey is a
	PK.

ACID
	Atomicity – transakcia je buď vykonaná celá alebo nie je vykonaná vôbec
		nemôže byť vykonaná iba časť operácií
	Consistency - vykonanie transakcie znamená prechod od konzistentného stavu DB
		opäť do konzistentného stavu DB – túto požiadavku zabezpečuje implementátor
		transakcie/aplikácie alebo DBMS modul, ktorý je zodpovedný za dodržiavanie
		integritných obmedzení.
	Isolation – napriek tomu, že systém môže vykonávať viacero transakcií ”paralelne”,
		výsledný efekt musí byť rovnaký ako keby boli dané transakcie vykonávané sériovo
		(jedna po druhej)
	Durability – ak transakcia úspešne skončí (systém vykoná COMMIT), tak všetky
		zmeny, ktoré boli vykonané v DB budú navždy zachované

Myšlienkou za generovaním dobrých rozvrhov je
	• postupnosť nekonfliktných operácií je možné ľubovoľne premiešať a rozvrh ostane dobrý (je dosiahnutý správny výsledok).
	• postupnosť konfliktných operácií je potrebné zachovať
	• projekciu na jednotlivé transakcie je potrebné tiež zachovať – nie je možné premiešať postupnosť operácií v samotných transakciách.

Problémy, ktoré môžu nastať v rámci súbežného spracovania:
	• Lost Update problem
	• Zmenenie hodnôt v rovnakom čase
	• Dirty read problem
	• Čítanie hodnoty, ktorá nebola ešte commitnuta a teda môže stále zlyhať
	• Incorrect summary problem
	• Výpočet agregačnej funkcie a medzi tým iná transakcia zmenila niektorú z hodnôt takže je vypočítaná nesprávna hodnota

Conflict serialization 
	Both T1 and T2 read/write to the same variable x.
	
	If both transactions commit and the schedule is not serial, we must check if their interleaving can be reordered to a serial one by only swapping non-conflicting operations.
	
	If yes → Conflict-serializable

View-ekvivalentné
	• Hovoríme, že v rozvrhu transakcia T2 číta X od transakcie T1, ak v tom rozvrhu existuje operácie w1(X) a r2(X), pričom w1(X) je posledný zápis do X pred r2(X)

Izolacia : 2 typy protokolov pre riadenie subeznosti Optimisticke(riesia konflikt ked k nemu dojde) a Pesimisticke (snazi sa zamedzit vzniku konfliktov)

Lock-Based Protocols - označované aj ako Algoritmus zámkov
	• transakcie zamykajú dátové objekty pred čítaním a zápisom aby iné transakcie s nimi nemohli ľubovoľne zaobchádzať
Timestamp-Based Protocols – označovaný ako algoritmus časových pečiatok
	• na základe časových pečiatok sa systém rozhoduje pri operáciách read/write či transakcia bude pokračovať alebo nie
Optimistic concurrency-control – označovaný ako validačný algoritmus
	• optimistický prístup, ktorý vykonáva operácie tak ako idú. Prísne kontroluje, či dovolí COMMIT
Multiversion Schemes – označovaný Multiversion algoritmus
	• každá transakcia si zapisuje svoj zmeny do svojej lokálnej kópie databázy (nezapisuje sa do hlavnej/ostrej databázy). Systém sa až pri žiadosti o COMMIT rozhodne, či sa dané zmeny zapíšu do DB alebo nie.
	• Systém musí udržiavať viacero kópií dátového objektu a tiež musí rozhodovať, ktorá verzia sa bude čítať pri operácií READ
	Existencia rôznych verzií
		• Timestamp Ordering
		• Two-Phase Locking
		• Snapshot Isolation

Zamykanie (locking)
	• Transakcia môže získať RL zámok na objekt X v prípade, že na objekt X nie je žiaden zámok alebo je zámok typu RL. V tedy transakcia môže získať zámok typu RL
	• V prípade, že transakcia T žiada o zámok typu WL nad objektom X, tak je to možné iba v prípade, že nad objektom nie je žiaden zámok.
	• V prípade, že nemôže v daný okamžik získať požadovaný typ zámku tak je transakcia priradená na čakaciu listinu.
	• Čo ak transakcia T vlastní ako jedina zámok typu RL nad objektom X a žiada o zámok WL nad objektom X ?
	relačná algebra:
		procedurálny prístup
		dopyt definuje iba plán ako má dbms nájsť požadované dáta	
		využíva sa napr v oblasti optimalizácie exekučných plánov sql

	relačný kalkulus:
		neprocedurálny prístup 
		dopyt hovorí aké dáta chceme získať a nie ako sa k nim dostať
	sql:stavia na relačnej algebre a relačnom kalkule


	Identity map pattern
		basicallly just a thing that stores db data in cache and returns em if same query is done 
	
	Unit of Work pattern
		makes query after changes are commited . Usually combined with Identity map or an ORM session or entity manager
