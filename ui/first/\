import random
import copy


# 12 x 10
mapy = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, "K", 0, 0, 0, 0, 0, 0],
    [0, "K", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, "K", 0, 0, 0, 0, 0, 0, 0],
    [0, 0, "K", 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, "K", "K", 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
]
mapy_shape = [len(mapy), len(mapy[0])]
number_of_positions = 10
number_of_steps = 300


class Kitten:
    def __init__(self):
        def random_position():
            # this boolean determines where its on the horizontal{0} or vertical{1} edge
            side = bool(random.getrandbits(1))
            opposite_side = not side
            result = None
            if side:
                result = [
                    random.randint(0, mapy_shape[opposite_side] - 1),
                    0 if random.getrandbits(1) else (mapy_shape[side] - 1),
                ]
            else:
                result = [
                    0 if random.getrandbits(1) else (mapy_shape[side] - 1),
                    random.randint(0, mapy_shape[opposite_side] - 1),
                ]
            return result

        # specific steps kitten will take
        self.steps = random.choices(["l", "r", "u", "d"], k=number_of_steps)
        # start_positions where the kitten will spawn afeter it leaves the field
        self.start_positions = []
        self.start_positions_index = 0
        for i in range(number_of_positions):
            x = random_position()
            while x in self.start_positions:
                x = random_position()
            self.start_positions.append(x)
        self.score = 0
        self.mapc = copy.deepcopy(mapy)
        self.last_instruction = ""
        # current position
        self.position = []
        self.number = 0

        # current index of kitten in start_positions
        self.i = 0
        # start fella

    def move(self):
        def out_of_bounds_check(self):
            if (
                not self.position
                or self.position[0] is None
                or self.position[1] is None
            ):
                return True
            if (
                self.position[0] >= 0
                and self.position[0] < mapy_shape[0]
                and self.position[1] >= 0
                and self.position[1] < mapy_shape[1]
            ):
                return False
            return True

        # finds if the position my kitten is trying to access is available
        def find_empty_start_position(self):
            while self.start_positions_index < number_of_positions:
                positions = self.start_positions[self.start_positions_index]
                if self.mapc[positions[0]][positions[1]] == 0:
                    self.start_positions_index += 1
                    # if statements to make sure he doesnt go to one space and then right back
                    if positions[0] == 0:
                        self.last_instruction = "d"
                    elif (positions[0] == 0 or positions[0] == mapy_shape[0] - 1) and (
                        positions[0] == 0 or positions[0] == mapy_shape[0] - 1
                    ):  # checks if im in the corner
                        self.last_instruction == ""
                    elif positions[0] == mapy_shape[0] - 1:
                        self.last_instruction = "u"
                    elif positions[1] == 0:
                        self.last_instruction = "r"
                    elif positions[1] == mapy_shape[1] - 1:
                        self.last_instruction = "l"
                    return positions[0], positions[1]
                else:
                    self.start_positions_index += 1

            return None, None

        # variable to check if the kitten is out of the field or no
        while self.i < number_of_steps:
            # longass error to keep python from displaying annoying errors that arent errors ! >:[
            if (
                not self.position
                or self.position[0] is None
                or self.position[1] is None
                or out_of_bounds_check(self)
            ):
                y, x = find_empty_start_position(self)
                if x == None and y == None:
                    break
                else:
                    self.position = [y, x]
                    self.number += 1
                    self.mapc[self.position[0]][self.position[1]] = self.number
            else:
                # todo check if can step else kill kitten
                # todo fix this shit
                while self.i < number_of_steps:
                    if (
                        self.steps[self.i] == "u"
                        and self.last_instruction != "d"
                        and (
                            self.position[0] - 1 < 0
                            or self.mapc[self.position[0] - 1][self.position[1]] == 0
                        )
                    ):
                        if self.position[0] - 1 < 0:
                            self.position = []
                        else:
                            self.position = [self.position[0] - 1, self.position[1]]
                            self.mapc[self.position[0]][self.position[1]] = self.number
                            self.score += 1
                        self.i += 1
                        break
                    elif (
                        self.steps[self.i] == "d"
                        and self.last_instruction != "u"
                        and (
                            self.position[0] + 1 >= mapy_shape[0]
                            or self.mapc[self.position[0] + 1][self.position[1]] == 0
                        )
                    ):
                        if self.position[0] + 1 >= mapy_shape[0]:
                            self.position = []
                        else:
                            self.position = [self.position[0] + 1, self.position[1]]
                            self.mapc[self.position[0]][self.position[1]] = self.number
                            self.score += 1
                        self.i += 1
                        break
                    elif (
                        self.steps[self.i] == "l"
                        and self.last_instruction != "r"
                        and (
                            self.position[1] - 1 < 0
                            or self.mapc[self.position[0]][self.position[1] - 1] == 0
                        )
                    ):
                        if self.position[1] - 1 < 0:
                            self.position = []
                        else:
                            self.position = [self.position[0], self.position[1] - 1]
                            self.mapc[self.position[0]][self.position[1]] = self.number
                            self.score += 1
                        self.i += 1
                        break
                    elif (
                        self.steps[self.i] == "r"
                        and self.last_instruction != "l"
                        and (
                            self.position[1] + 1 >= mapy_shape[1]
                            or self.mapc[self.position[0]][self.position[1] + 1] == 0
                        )
                    ):
                        if self.position[1] + 1 >= mapy_shape[1]:
                            self.position = []
                        else:
                            self.position = [self.position[0], self.position[1] + 1]
                            self.mapc[self.position[0]][self.position[1]] = self.number
                            self.score += 1
                        self.i += 1
                        break
                    self.i += 1
                # step

        self.print_map()

    def start(self):

        self.move()
        return self.score

    def print_map(self):
        for row in self.mapc:
            mystring = ""
            for c in row:
                mystring += " " + str(c) + " "
            print(mystring + "\n")


kittens = [Kitten() for _ in range(5)]
kitten_result_array = []
for kitten in kittens:
    kitten_score = kitten.start()
    kitten_result_array.append([kitten, kitten_score])
    print(kitten_score)
print(mapy)
